commit fd12c854ef3d88b3a4e7669b79398ad81f68c076
Author: Haozhong Zhang <haozhong.zhang@intel.com>
Date:   Thu Apr 28 21:17:12 2016 +0800

    acpi: patch guest ACPI for pc-lite
    
    Traditionally, guest BIOS is responsible to allocate memory/fill
    address/fill checksum for some guest ACPI tables. However, pc-lite does
    not use any guest BIOS. Therefore, we have to do above patching work in
    qemu for pc-lite.
    
    Signed-off-by: Haozhong Zhang <haozhong.zhang@intel.com>

diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 2181122..b3f472b 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -27,6 +27,7 @@
 #include "qemu-common.h"
 #include "qemu/bitmap.h"
 #include "qemu/error-report.h"
+#include "qemu/mmap-alloc.h"
 #include "hw/pci/pci.h"
 #include "qom/cpu.h"
 #include "hw/i386/pc.h"
@@ -55,6 +56,7 @@
 #include "hw/timer/hpet.h"
 
 #include "hw/acpi/aml-build.h"
+#include "hw/acpi/bios-linker-loader.h"
 
 #include "qapi/qmp/qint.h"
 #include "qom/qom-qobject.h"
@@ -1992,6 +1994,7 @@ build_dsdt(GArray *table_data, GArray *linker,
     GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);
     GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);
     PCMachineState *pcms = PC_MACHINE(machine);
+    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
     uint32_t nr_mem = machine->ram_slots;
     int root_bus_limit = 0xFF;
     PCIBus *bus = NULL;
@@ -2241,8 +2244,8 @@ build_dsdt(GArray *table_data, GArray *linker,
     aml_append(scope, aml_name_decl("_S5", pkg));
     aml_append(dsdt, scope);
 
-    /* create fw_cfg node, unconditionally */
-    {
+    /* create fw_cfg node if a guest BIOS is used */
+    if (!pcmc->no_bios) {
         /* when using port i/o, the 8-bit data register *always* overlaps
          * with half of the 16-bit control register. Hence, the total size
          * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the
@@ -2883,14 +2886,281 @@ static const VMStateDescription vmstate_acpi_build = {
     },
 };
 
+struct AcpiData {
+    MemoryRegion *mr;    /* memory region where ACPI data is */
+    void         *src;
+    uint64_t     offset; /* offset within the memory region */
+    uint64_t     size;   /* size of ACPI data */
+};
+static struct AcpiData acpi_rsdp_data;   /* RSDP */
+static struct AcpiData acpi_tables_data; /* Other ACPI tables */
+static struct AcpiData acpi_loader_linker;
+
+struct AcpiDataAllocator {
+    MemoryRegion *mr;
+    uint64_t     start;
+    uint64_t     offset;
+};
+static struct AcpiDataAllocator acpi_himem_allocator;
+static struct AcpiDataAllocator acpi_fseg_allocator;
+
+#define ACPI_HIMEM_SIZE (256 * 1024)
+#define ACPI_FSEG_SIZE  (0x100000 - 0xe0000)
+
+static struct AcpiDataAllocator *acpi_loader_get_allocator(uint8_t zone)
+{
+    struct AcpiDataAllocator *alloc = NULL;
+    if (zone == BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH) {
+        alloc = &acpi_himem_allocator;
+    } else if (zone == BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG) {
+        alloc = &acpi_fseg_allocator;
+    }
+    return alloc;
+}
+
+static struct AcpiData *acpi_loader_get_data(const char *name)
+{
+    struct AcpiData *data = NULL;
+    if (!strncmp(name, ACPI_BUILD_TABLE_FILE, BIOS_LINKER_LOADER_FILESZ)) {
+        data = &acpi_tables_data;
+    } else if (!strncmp(name, ACPI_BUILD_RSDP_FILE, BIOS_LINKER_LOADER_FILESZ)) {
+        data = &acpi_rsdp_data;
+    }
+    return data;
+}
+
+static uint64_t acpi_loader_get_addr(struct AcpiData *data)
+{
+    return data->mr->addr + data->offset;
+}
+
+static void *acpi_loader_get_ptr(struct AcpiData *data)
+{
+    void *ptr = memory_region_get_ram_ptr(data->mr);
+    return ptr + data->offset;
+}
+
+static int acpi_loader_allocator_init(struct AcpiDataAllocator *allocator,
+                                      const char *name,
+                                      uint64_t start, uint64_t size)
+{
+    void *buf;
+    MemoryRegion *mr;
+
+    buf = qemu_ram_mmap(-1, size, 0x1000, true);
+    if (buf == MAP_FAILED) {
+        return -1;
+    }
+
+    mr = g_malloc(sizeof(*mr));
+    if (!mr) {
+        qemu_ram_munmap(buf, size);
+        return -1;
+    }
+
+    memory_region_init_ram_ptr(mr, NULL, name, size, buf);
+    memory_region_add_subregion_overlap(get_system_memory(), start, mr, 0);
+    e820_add_entry(start, size, E820_RESERVED);
+
+    allocator->mr = mr;
+    allocator->start = start;
+    allocator->offset = 0;
+
+    return 0;
+}
+
+static void acpi_loader_alloc_init(PCMachineState *pcms)
+{
+    uint64_t start;
+    int rc;
+
+    assert(pcms->below_4g_mem_size >= ACPI_HIMEM_SIZE);
+    start = pcms->below_4g_mem_size - ACPI_HIMEM_SIZE;
+    rc = acpi_loader_allocator_init(&acpi_himem_allocator, "acpi-himem",
+                                    start, ACPI_HIMEM_SIZE);
+    assert(!rc);
+
+    rc = acpi_loader_allocator_init(&acpi_fseg_allocator, "acpi-fseg",
+                                    0xe0000, ACPI_FSEG_SIZE);
+    assert(!rc);
+}
+
+/* return the offset in the corresponding zone, or ~0 for failure */
+static uint64_t acpi_loader_alloc(struct AcpiDataAllocator *alloc,
+                                  uint64_t size, uint32_t align)
+{
+    uint64_t start = alloc->start;
+    uint64_t offset = alloc->offset;
+    uint64_t max_size = memory_region_size(alloc->mr);
+    uint64_t addr;
+
+    addr = ROUND_UP(start + offset, align);
+    offset = addr - start;
+    if (size > max_size || max_size - size < offset) {
+        return ~(uint64_t) 0;
+    }
+    alloc->offset = offset + size;
+
+    return offset;
+}
+
+static int acpi_loader_patch_allocate(BiosLinkerLoaderEntry *entry)
+{
+    uint8_t zone = entry->alloc.zone;
+    struct AcpiDataAllocator *alloc;
+    struct AcpiData *data;
+    uint64_t offset;
+    void *dest;
+
+    alloc = acpi_loader_get_allocator(zone);
+    if (!alloc) {
+        ACPI_BUILD_DPRINTF("Allocate: unknown zone type %u\n", zone);
+        return -1;
+    }
+    data = acpi_loader_get_data(entry->alloc.file);
+    if (!data) {
+        ACPI_BUILD_DPRINTF("Allocate: Unknown file: %s\n",
+                           entry->alloc.file);
+        return -1;
+    }
+    assert(data->src);
+
+    offset = acpi_loader_alloc(alloc, data->size, entry->alloc.align);
+    if (offset == ~(uint64_t) 0) {
+        return -1;
+    }
+
+    dest = memory_region_get_ram_ptr(alloc->mr);
+    memcpy(dest + offset, data->src, data->size);
+    memory_region_set_dirty(alloc->mr, offset, data->size);
+
+    data->mr = alloc->mr;
+    data->offset = offset;
+    g_free(data->src);
+    data->src = NULL;
+
+    ACPI_BUILD_DPRINTF("Allocate: file %s, zone %d, align 0x%"PRIx32"\n",
+                       entry->alloc.file, zone, entry->alloc.align);
+    ACPI_BUILD_DPRINTF("          size 0x%"PRIx32", GPA 0x%"PRIx32"\n",
+                       (uint32_t) data->size,
+                       (uint32_t) acpi_loader_get_addr(data));
+
+    return 0;
+}
+
+static int acpi_loader_patch_add_pointer(BiosLinkerLoaderEntry *entry)
+{
+    struct AcpiData *dest_data, *src_data;
+    void *dest;
+    uint64_t pointer = 0;
+    uint32_t offset = entry->pointer.offset;
+    uint32_t size = entry->pointer.size;
+
+    ACPI_BUILD_DPRINTF(
+        "Add_pointer: dst file %s, src file %s, offset 0x%"PRIx32", size 0x%x\n",
+        entry->pointer.dest_file, entry->pointer.src_file,
+        entry->pointer.offset, entry->pointer.size);
+
+    dest_data = acpi_loader_get_data(entry->pointer.dest_file);
+    if (!dest_data) {
+        ACPI_BUILD_DPRINTF("Add_pointer: unknown destination file %s\n",
+                           entry->pointer.dest_file);
+        return -1;
+    }
+    src_data = acpi_loader_get_data(entry->pointer.src_file);
+    if (!src_data) {
+        ACPI_BUILD_DPRINTF("Add_pointer: unknown source file %s\n",
+                           entry->pointer.src_file);
+        return -1;
+    }
+
+    ACPI_BUILD_DPRINTF(
+        "             dst @ GPA 0x%"PRIx64", src @ GPA 0x%"PRIx64"\n",
+        dest_data->mr->addr, src_data->mr->addr);
+
+    dest = acpi_loader_get_ptr(dest_data);
+    memcpy(&pointer, dest + offset, size);
+    ACPI_BUILD_DPRINTF(
+        "             original value 0x%"PRIx64"\n", pointer);
+    pointer += acpi_loader_get_addr(src_data);
+    ACPI_BUILD_DPRINTF(
+        "             modified value 0x%"PRIx64"\n", pointer);
+    memcpy(dest + offset, &pointer, size);
+    memory_region_set_dirty(dest_data->mr, dest_data->offset + offset, size);
+
+    return 0;
+}
+
+static int acpi_loader_patch_add_checksum(BiosLinkerLoaderEntry *entry)
+{
+    struct AcpiData *data;
+    uint32_t offset = entry->cksum.offset;
+    uint8_t *dest, *cksum;
+
+    data = acpi_loader_get_data(entry->cksum.file);
+    if (!data) {
+        ACPI_BUILD_DPRINTF(
+            "Add_checksum: unknown ACPI table %s\n", entry->cksum.file);
+        return -1;
+    }
+    dest = acpi_loader_get_ptr(data);
+    cksum = dest + offset;
+    *cksum = acpi_checksum(dest + entry->cksum.start, entry->cksum.length);
+    memory_region_set_dirty(data->mr, data->offset + offset, sizeof(*cksum));
+
+    ACPI_BUILD_DPRINTF("Add_checksum: file %s, offset 0x%"PRIx32", "
+                       "start 0x%"PRIx32", length 0x%"PRIx32"\n",
+                       entry->cksum.file, entry->cksum.offset,
+                       entry->cksum.start, entry->cksum.length);
+    ACPI_BUILD_DPRINTF("              checksum 0x%02x\n", *cksum);
+
+    return 0;
+}
+
+/**
+ * Patch guest ACPI which is usually done by guest BIOS.
+ * XXX: should be only called when no guest BIOS is used
+ */
+static void acpi_loader_patch(AcpiBuildState *build_state)
+{
+    void *data = acpi_loader_linker.src;
+    uint64_t len = acpi_loader_linker.size;
+    uint64_t offset;
+    BiosLinkerLoaderEntry *entry;
+    int rc = 0;
+
+    for (offset = 0; offset < len; offset += sizeof(*entry)) {
+        entry = data + offset;
+        switch (entry->command) {
+        case BIOS_LINKER_LOADER_COMMAND_ALLOCATE:
+            rc = acpi_loader_patch_allocate(entry);
+            break;
+        case BIOS_LINKER_LOADER_COMMAND_ADD_POINTER:
+            rc = acpi_loader_patch_add_pointer(entry);
+            break;
+        case BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM:
+            rc = acpi_loader_patch_add_checksum(entry);
+            break;
+        default:
+            continue;
+        }
+    }
+
+    if (!rc) {
+        build_state->patched = 1;
+    }
+}
+
 void acpi_setup(void)
 {
     PCMachineState *pcms = PC_MACHINE(qdev_get_machine());
     PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
     AcpiBuildTables tables;
     AcpiBuildState *build_state;
+    FWCfgState *fw_cfg = pcms->fw_cfg;
+    bool nobios = pcmc->no_bios;
 
-    if (!pcms->fw_cfg) {
+    if (!fw_cfg && !nobios) {
         ACPI_BUILD_DPRINTF("No fw cfg. Bailing out.\n");
         return;
     }
@@ -2912,35 +3182,50 @@ void acpi_setup(void)
     acpi_build_tables_init(&tables);
     acpi_build(&tables, MACHINE(pcms));
 
-    /* Now expose it all to Guest */
-    build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,
-                                               ACPI_BUILD_TABLE_FILE,
-                                               ACPI_BUILD_TABLE_MAX_SIZE);
-    assert(build_state->table_mr != NULL);
+    if (!nobios) {
+        /* Now expose it all to Guest */
+        build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,
+                                                  ACPI_BUILD_TABLE_FILE,
+                                                  ACPI_BUILD_TABLE_MAX_SIZE);
+        assert(build_state->table_mr != NULL);
 
-    build_state->linker_mr =
-        acpi_add_rom_blob(build_state, tables.linker, "etc/table-loader", 0);
+        build_state->linker_mr =
+            acpi_add_rom_blob(build_state, tables.linker, "etc/table-loader", 0);
 
-    fw_cfg_add_file(pcms->fw_cfg, ACPI_BUILD_TPMLOG_FILE,
-                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));
+        fw_cfg_add_file(fw_cfg, ACPI_BUILD_TPMLOG_FILE,
+                        tables.tcpalog->data, acpi_data_len(tables.tcpalog));
+    } else {
+        acpi_tables_data.size = acpi_data_len(tables.table_data);
+        acpi_tables_data.src = g_memdup(tables.table_data->data,
+                                        acpi_tables_data.size);
 
-    if (!pcmc->rsdp_in_ram) {
-        /*
-         * Keep for compatibility with old machine types.
-         * Though RSDP is small, its contents isn't immutable, so
-         * we'll update it along with the rest of tables on guest access.
-         */
-        uint32_t rsdp_size = acpi_data_len(tables.rsdp);
+        acpi_loader_linker.size = acpi_data_len(tables.linker);
+        acpi_loader_linker.src = g_memdup(tables.linker->data,
+                                          acpi_loader_linker.size);
+    }
+
+    if (!nobios) {
+        if (!pcmc->rsdp_in_ram) {
+            /*
+             * Keep for compatibility with old machine types.
+             * Though RSDP is small, its contents isn't immutable, so
+             * we'll update it along with the rest of tables on guest access.
+             */
+            uint32_t rsdp_size = acpi_data_len(tables.rsdp);
 
-        build_state->rsdp = g_memdup(tables.rsdp->data, rsdp_size);
-        fw_cfg_add_file_callback(pcms->fw_cfg, ACPI_BUILD_RSDP_FILE,
-                                 acpi_build_update, build_state,
-                                 build_state->rsdp, rsdp_size);
-        build_state->rsdp_mr = NULL;
+            build_state->rsdp = g_memdup(tables.rsdp->data, rsdp_size);
+            fw_cfg_add_file_callback(fw_cfg, ACPI_BUILD_RSDP_FILE,
+                                     acpi_build_update, build_state,
+                                     build_state->rsdp, rsdp_size);
+            build_state->rsdp_mr = NULL;
+        } else {
+            build_state->rsdp = NULL;
+            build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,
+                                                     ACPI_BUILD_RSDP_FILE, 0);
+        }
     } else {
-        build_state->rsdp = NULL;
-        build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,
-                                                  ACPI_BUILD_RSDP_FILE, 0);
+        acpi_rsdp_data.size = acpi_data_len(tables.rsdp);
+        acpi_rsdp_data.src = g_memdup(tables.rsdp->data, acpi_rsdp_data.size);
     }
 
     qemu_register_reset(acpi_build_reset, build_state);
@@ -2951,4 +3236,12 @@ void acpi_setup(void)
      * in build_state.
      */
     acpi_build_tables_cleanup(&tables, false);
+
+    /* If no guest BIOS is given, we must patch the guest ACPI. */
+    if (nobios) {
+        acpi_loader_alloc_init(pcms);
+        acpi_loader_patch(build_state);
+        /* TODO: handle acpi_loader_patch() failure */
+        assert(build_state->patched);
+    }
 }

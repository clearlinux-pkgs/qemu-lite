commit 738e04e1d9022e9e0b963b0cbaf00a7c6b9d1d59
Author: Jim Kukunas <james.t.kukunas@linux.intel.com>
Co-Authored-By: Anthony Xu <anthony.xu@intel.com>
Date:   Wed Apr 6 11:30:01 2016 -0700

        skip bios and run uncompressed kernel,
        only support one vcpu due to the lack of mptable
    
        Signed-off-by: Chao Peng <chao.p.peng@linux.intel.com>

diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 9a1a634..bcf3ac7 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -37,6 +37,8 @@
 #include "hw/smbios/smbios.h"
 #include "hw/loader.h"
 #include "elf.h"
+#include "asm/bootparam.h"
+#include "linux/const.h"
 #include "multiboot.h"
 #include "hw/timer/mc146818rtc.h"
 #include "hw/timer/i8254.h"
@@ -814,7 +816,277 @@ static long get_file_size(FILE *f)
     return size;
 }
 
-static void load_linux(PCMachineState *pcms,
+#define BOOT_GDT       0x500
+#define BOOT_IDT       0x520
+
+#define BOOT_GDT_NULL  0
+#define BOOT_GDT_CODE  1
+#define BOOT_GDT_DATA  2
+#define BOOT_GDT_TSS   3
+#define BOOT_GDT_MAX   4
+
+/* Puts PML4 right after zero page but aligned to 4k */
+#define BOOT_PML4      0x9000
+#define BOOT_PDPTE     0xA000
+
+#define BOOT_LOADER_SP          0x8000
+#define BOOT_CMDLINE_OFFSET     0x20000
+#define BOOT_ZEROPAGE_OFFSET    0x7000
+
+/* Constructor for a conventional segment GDT (or LDT) entry */
+/* This is a macro so it can be used in initializers */
+#define GDT_ENTRY(flags, base, limit)                   \
+       ((((base)  & _AC(0xff000000,ULL)) << (56-24)) | \
+       (((flags) & _AC(0x0000f0ff,ULL)) << 40) |      \
+       (((limit) & _AC(0x000f0000,ULL)) << (48-16)) | \
+       (((base)  & _AC(0x00ffffff,ULL)) << 16) |      \
+       (((limit) & _AC(0x0000ffff,ULL))))
+
+static target_ulong eip;
+static void set_cpu_regs(CPUX86State *env)
+{
+    void *p;
+    size_t len;
+    __u64 idt = 0;
+    __u64 gdt[BOOT_GDT_MAX] = {     /* flags, base, limit */
+       [BOOT_GDT_NULL] = GDT_ENTRY(0, 0, 0),
+       [BOOT_GDT_CODE] = GDT_ENTRY(0xA09B, 0, 0xFFFFF),
+       [BOOT_GDT_DATA] = GDT_ENTRY(0xC093, 0, 0xFFFFF),
+       [BOOT_GDT_TSS ] = GDT_ENTRY(0x808B, 0, 0xFFFFF),
+    };
+
+    /*
+     * normally, we would jump to real-mode code (either the bootloader or
+     * the setup code in the bzImage. There's not point in doing that here,
+     * as we've already setup the zero page, so let's just setup protected
+     * mode and go straight into the kernel.
+     *
+     * startup_64 expect:
+     *      - CS.L=1 and CS.D = 0
+     *              0) start from protected mode, disable paging
+     *              1) enable PAE (CR4.PAE = 1)
+     *              2) load cr3 w/ PML4
+     *              3) set IA32_EFER.LME=1
+     *              4) enable paging CR0.PG=1
+     *      - identity mapped page tables
+     *      - rsi has real_mode_data ptr
+     */
+
+    /* Segments */
+    cpu_physical_memory_write((hwaddr)BOOT_GDT, gdt, sizeof(gdt));
+    env->gdt.base = BOOT_GDT;
+    env->gdt.limit = sizeof(gdt)-1;
+
+    cpu_physical_memory_write((hwaddr)BOOT_IDT, &idt, sizeof(idt));
+    env->idt.base = BOOT_IDT;
+    env->idt.limit = sizeof(idt)-1;
+
+    cpu_x86_load_seg_cache(env, R_CS, BOOT_GDT_CODE * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_CS_MASK |
+                           DESC_R_MASK | DESC_A_MASK | DESC_L_MASK |
+                           DESC_G_MASK);
+
+    cpu_x86_load_seg_cache(env, R_DS, BOOT_GDT_DATA * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |
+                           DESC_A_MASK | DESC_B_MASK | DESC_G_MASK);
+    cpu_x86_load_seg_cache(env, R_ES, BOOT_GDT_DATA * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |
+                           DESC_A_MASK | DESC_B_MASK | DESC_G_MASK);
+    cpu_x86_load_seg_cache(env, R_FS, BOOT_GDT_DATA * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |
+                           DESC_A_MASK | DESC_B_MASK | DESC_G_MASK);
+    cpu_x86_load_seg_cache(env, R_GS, BOOT_GDT_DATA * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |
+                           DESC_A_MASK | DESC_B_MASK | DESC_G_MASK);
+    cpu_x86_load_seg_cache(env, R_SS, BOOT_GDT_DATA * 8, 0, 0xfffff,
+                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |
+                           DESC_A_MASK | DESC_B_MASK | DESC_G_MASK);
+
+    env->tr.selector = BOOT_GDT_TSS * 8;
+    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);
+
+    /* Page Tables */
+    len = 4096;
+    p = cpu_physical_memory_map(BOOT_PML4, &len, 1);
+    memset(p, 0, 4096);
+    *(__u64 *)p = (__u64)(BOOT_PDPTE | 3);
+    cpu_physical_memory_unmap(p, len, 1, len);
+
+    len = 4096;
+    p = cpu_physical_memory_map(BOOT_PDPTE, &len, 1);
+    memset(p, 0, 4096);
+    *(__u64 *)p = 0x83;
+    cpu_physical_memory_unmap(p, len, 1, len);
+
+    env->cr[3] = BOOT_PML4;
+    env->cr[4] |= CR4_PAE_MASK;
+    env->cr[0] |= CR0_PG_MASK;
+
+    /* 64-bit protected mode */
+    env->cr[0] |= CR0_PE_MASK;
+    env->efer |= MSR_EFER_LME;
+
+    env->regs[R_ESP] = BOOT_LOADER_SP;
+    env->regs[R_ESI] = BOOT_ZEROPAGE_OFFSET;
+    env->eip = eip;
+}
+
+static void set_zero_page(char* kernel_cmdline)
+{
+    size_t cmdline_size, zero_page_size;
+    struct boot_params *zero_page;
+    int i;
+
+    cmdline_size = strlen(kernel_cmdline) + 1;
+    cpu_physical_memory_write((hwaddr)BOOT_CMDLINE_OFFSET, kernel_cmdline, cmdline_size);
+
+    zero_page_size =  sizeof(struct boot_params);
+    zero_page = cpu_physical_memory_map((hwaddr)BOOT_ZEROPAGE_OFFSET,
+                                        &zero_page_size, 1);
+    if (!zero_page) {
+        fprintf(stderr,"unable to map zeropage: %s\n", strerror(errno));
+        exit(1);
+    }
+
+    memset(zero_page, 0, zero_page_size);
+    zero_page->hdr.type_of_loader = 0xFF;
+    zero_page->hdr.boot_flag = 0xAA55;
+    zero_page->hdr.header = 0x53726448;
+    zero_page->hdr.cmd_line_ptr = BOOT_CMDLINE_OFFSET;
+    zero_page->hdr.cmdline_size = cmdline_size;
+
+    for (i = 0; i < e820_entries; i++) {
+        zero_page->e820_map[i].addr = e820_table[i].address;
+        zero_page->e820_map[i].size = e820_table[i].length;
+        zero_page->e820_map[i].type = e820_table[i].type;
+    }
+    zero_page->e820_entries = e820_entries;
+
+    cpu_physical_memory_unmap(zero_page, zero_page_size, 1, zero_page_size);
+}
+
+static int load_linux_elf32(FILE *f)
+{
+    return false;
+}
+
+static bool load_linux_elf64(FILE *f)
+{
+    bool ret = false;
+    size_t bytes;
+    size_t buflen;
+    Elf64_Off ph_off;
+    Elf64_Half ph_entsz;
+    Elf64_Half ph_cnt;
+    Elf64_Half ph_i;
+    Elf64_Phdr *phdr = NULL;
+    Elf64_Ehdr hdr;
+
+    fseek(f, 0, 0);
+    bytes = fread(&hdr, 1, sizeof(Elf64_Ehdr), f);
+    if (bytes != sizeof(Elf64_Ehdr)) {
+        fprintf(stderr, "unable to read ELF64 hdr: %s\n", strerror(errno));
+        return false;
+    }
+    ph_off = hdr.e_phoff;
+    ph_entsz = hdr.e_phentsize;
+    ph_cnt = hdr.e_phnum;
+    buflen = ph_entsz * ph_cnt;
+
+    phdr = malloc(buflen);
+    if (!phdr) {
+        fprintf(stderr,"unable to allocate program header buffer\n");
+        return false;
+    }
+
+    fseek(f, ph_off, 0);
+
+    bytes = fread(phdr, 1, buflen, f);
+    if (bytes != buflen) {
+        fprintf(stderr,"unable to read program header: %s\n", strerror(errno));
+        goto out;
+    }
+
+    /* FIXME mmap */
+    for (ph_i = 0; ph_i < ph_cnt; ph_i++) {
+        char *dst;
+        size_t off = phdr[ph_i].p_offset;
+        size_t len = phdr[ph_i].p_filesz;
+        uint64_t addr = phdr[ph_i].p_paddr;
+
+        if ((phdr[ph_i].p_type & PT_LOAD) == 0) {
+            continue;
+        }
+
+        dst = cpu_physical_memory_map(addr, &len, 1);
+        if (!dst) {
+           fprintf(stderr,"unable to map segment: %s\n", strerror(errno));
+           goto out;
+        }
+        fseek(f, off, 0);
+        bytes = fread(dst, 1, len, f);
+        cpu_physical_memory_unmap(dst, len, 1, len);
+
+        if (bytes != len) {
+            fprintf(stderr,"unable to load segment: %s\n", strerror(errno));
+            goto out;
+        }
+    }
+
+    eip = hdr.e_entry;
+    ret = true;
+
+out:
+    free(phdr);
+    return ret;
+}
+
+static bool load_linux_efi(MachineState *machine)
+{
+    bool ret = false;
+    FILE *f;
+    char ident[EI_NIDENT];
+    unsigned char class;
+    size_t bytes;
+
+    f = fopen(machine->kernel_filename, "rb");
+    if (!f) {
+        fprintf(stderr, "unable to open file: %s\n", machine->kernel_filename);
+        return false;
+    }
+
+    bytes = fread(ident, 1, sizeof(ident), f);
+    if (bytes != sizeof(ident)) {
+        fprintf(stderr, "unable to read elf ident: %s\n",
+                        machine->kernel_filename);
+        goto out;
+    }
+
+    if (strncmp(ident, ELFMAG, SELFMAG)) {
+        goto out;
+    }
+
+    class = ident[EI_CLASS];
+    if (class != ELFCLASS32 && class != ELFCLASS64) {
+        goto out;
+    }
+
+    if (ident[EI_DATA] != ELFDATA2LSB) {
+        goto out;
+    }
+
+    if (class == ELFCLASS32) {
+        ret = load_linux_elf32(f);
+    } else {
+        ret = load_linux_elf64(f);
+    }
+
+out:
+    fclose(f);
+    return ret;
+}
+
+static void load_linux_bzimage(PCMachineState *pcms,
                        FWCfgState *fw_cfg)
 {
     uint16_t protocol;
@@ -1261,7 +1533,7 @@ void xen_load_linux(PCMachineState *pcms)
     fw_cfg = fw_cfg_init_io(FW_CFG_IO_BASE);
     rom_set_fw(fw_cfg);
 
-    load_linux(pcms, fw_cfg);
+    load_linux_bzimage(pcms, fw_cfg);
     for (i = 0; i < nb_option_roms; i++) {
         assert(!strcmp(option_rom[i].name, "linuxboot.bin") ||
                !strcmp(option_rom[i].name, "multiboot.bin"));
@@ -1389,7 +1661,15 @@ void pc_memory_init(PCMachineState *pcms,
     }
 
     if (linux_boot) {
-        load_linux(pcms, fw_cfg);
+        if (pcms->no_bios) {
+            if (!load_linux_efi(machine)) {
+                error_report("load elf kernel failed: %s",
+                              machine->kernel_filename);
+                exit(EXIT_FAILURE);
+            }
+        } else {
+            load_linux_bzimage(pcms, fw_cfg);
+        }
     }
 
     for (i = 0; i < nb_option_roms; i++) {
@@ -1907,6 +2187,20 @@ static void pc_machine_set_nvdimm(Object *obj, bool value, Error **errp)
     pcms->acpi_nvdimm_state.is_enabled = value;
 }
 
+static bool pc_machine_get_no_bios(Object *obj, Error **errp)
+{
+    PCMachineState *pcms = PC_MACHINE(obj);
+
+    return pcms->no_bios;
+}
+
+static void pc_machine_set_no_bios(Object *obj, bool value, Error **errp)
+{
+    PCMachineState *pcms = PC_MACHINE(obj);
+
+    pcms->no_bios = value;
+}
+
 static void pc_machine_initfn(Object *obj)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -1946,12 +2240,19 @@ static void pc_machine_initfn(Object *obj)
     pcms->acpi_nvdimm_state.is_enabled = false;
     object_property_add_bool(obj, PC_MACHINE_NVDIMM, pc_machine_get_nvdimm,
                              pc_machine_set_nvdimm, &error_abort);
+
+    pcms->no_bios = false;
+    object_property_add_bool(obj, PC_MACHINE_NO_BIOS, pc_machine_get_no_bios,
+                             pc_machine_set_no_bios, &error_abort);
+
 }
 
 static void pc_machine_reset(void)
 {
     CPUState *cs;
     X86CPU *cpu;
+    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());
+    MachineState *machine = MACHINE(pcms);
 
     qemu_devices_reset();
 
@@ -1964,6 +2265,11 @@ static void pc_machine_reset(void)
         if (cpu->apic_state) {
             device_reset(cpu->apic_state);
         }
+
+        if (pcms->no_bios && cpu_is_bsp(cpu)) {
+            set_cpu_regs(&cpu->env);
+            set_zero_page(machine->kernel_cmdline);
+        }
     }
 }
 
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index a5fd27e..e05e47b 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -57,6 +57,7 @@ struct PCMachineState {
     uint64_t max_ram_below_4g;
     OnOffAuto vmport;
     OnOffAuto smm;
+    bool no_bios;
 
     AcpiNVDIMMState acpi_nvdimm_state;
 
@@ -80,6 +81,7 @@ struct PCMachineState {
 #define PC_MACHINE_VMPORT           "vmport"
 #define PC_MACHINE_SMM              "smm"
 #define PC_MACHINE_NVDIMM           "nvdimm"
+#define PC_MACHINE_NO_BIOS          "no-bios"
 
 /**
  * PCMachineClass:

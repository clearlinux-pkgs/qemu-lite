commit a6047cf09280723994a7bfa773ae89f2cf2849b6
Author: Anthony Xu <anthony.xu@intel.com>
Date:   Thu Jun 16 22:09:25 2016 -0700

    make initialization threads execute in parallel

diff --git a/cpus.c b/cpus.c
index cbeb1f6..cc81af1 100644
--- a/cpus.c
+++ b/cpus.c
@@ -712,6 +712,16 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+void cpu_synchronize_all_states_async(void)
+{
+    CPUState *cpu;
+
+    CPU_FOREACH(cpu) {
+        cpu_synchronize_state_async(cpu);
+    }
+}
+
+
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
@@ -721,6 +731,15 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+void cpu_synchronize_all_post_reset_async(void)
+{
+    CPUState *cpu;
+
+    CPU_FOREACH(cpu) {
+        cpu_synchronize_post_reset_async(cpu);
+    }
+}
+
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -730,6 +749,15 @@ void cpu_synchronize_all_post_init(void)
     }
 }
 
+void cpu_synchronize_all_post_init_async(void)
+{
+    CPUState *cpu;
+
+    CPU_FOREACH(cpu) {
+        cpu_synchronize_post_init_async(cpu);
+    }
+}
+
 static int do_vm_stop(RunState state)
 {
     int ret = 0;
@@ -1027,7 +1055,7 @@ static void qemu_tcg_wait_io_event(CPUState *cpu)
 static void qemu_kvm_wait_io_event(CPUState *cpu)
 {
     while (cpu_thread_is_idle(cpu)) {
-        qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);
+        qemu_cond_wait(cpu->halt_cond, cpu->mutex);
     }
 
     qemu_kvm_eat_signals(cpu);
@@ -1041,7 +1069,7 @@ static void *qemu_kvm_cpu_thread_fn(void *arg)
 
     rcu_register_thread();
 
-    qemu_mutex_lock_iothread();
+    qemu_mutex_lock(cpu->mutex);
     qemu_thread_get_self(cpu->thread);
     cpu->thread_id = qemu_get_thread_id();
     cpu->can_do_io = 1;
@@ -1052,9 +1080,7 @@ static void *qemu_kvm_cpu_thread_fn(void *arg)
         fprintf(stderr, "kvm_init_vcpu failed: %s\n", strerror(-r));
         exit(1);
     }
-
     qemu_kvm_init_cpu_signals(cpu);
-
     /* signal CPU creation */
     cpu->created = true;
     qemu_cond_signal(&qemu_cpu_cond);
@@ -1256,29 +1282,12 @@ void qemu_mutex_unlock_iothread(void)
     qemu_mutex_unlock(&qemu_global_mutex);
 }
 
-static int all_vcpus_paused(void)
-{
-    CPUState *cpu;
-
-    CPU_FOREACH(cpu) {
-        if (!cpu->stopped) {
-            return 0;
-        }
-    }
-
-    return 1;
-}
 
 void pause_all_vcpus(void)
 {
     CPUState *cpu;
 
     qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);
-    CPU_FOREACH(cpu) {
-        cpu->stop = true;
-        qemu_cpu_kick(cpu);
-    }
-
     if (qemu_in_vcpu_thread()) {
         cpu_stop_current();
         if (!kvm_enabled()) {
@@ -1290,11 +1299,15 @@ void pause_all_vcpus(void)
         }
     }
 
-    while (!all_vcpus_paused()) {
-        qemu_cond_wait(&qemu_pause_cond, &qemu_global_mutex);
-        CPU_FOREACH(cpu) {
-            qemu_cpu_kick(cpu);
+    CPU_FOREACH(cpu) {
+        qemu_mutex_lock(cpu->mutex);
+        cpu->stop = true;
+        qemu_cpu_kick(cpu);
+
+        while (!cpu->stopped) {
+            qemu_cond_wait(&qemu_pause_cond, cpu->mutex);
         }
+        qemu_mutex_unlock(cpu->mutex);
     }
 }
 
@@ -1315,6 +1328,20 @@ void resume_all_vcpus(void)
     }
 }
 
+void wait_for_all_vcpus_init(void)
+{
+    CPUState *cpu;
+    CPU_FOREACH(cpu) {
+        qemu_mutex_lock(cpu->mutex);
+        while (!cpu->created) {
+            qemu_cond_wait(&qemu_cpu_cond, cpu->mutex);
+        }
+        qemu_mutex_unlock(cpu->mutex);
+    }
+}
+
+
+
 /* For temporary buffers for forming a name */
 #define VCPU_THREAD_NAME_SIZE 16
 
@@ -1353,13 +1380,19 @@ static void qemu_kvm_start_vcpu(CPUState *cpu)
 
     cpu->thread = g_malloc0(sizeof(QemuThread));
     cpu->halt_cond = g_malloc0(sizeof(QemuCond));
+    cpu->mutex = g_malloc0(sizeof(QemuMutex));
     qemu_cond_init(cpu->halt_cond);
+    qemu_mutex_init(cpu->mutex);
+    cpu->queued_work_first = NULL;
+    cpu->queued_work_last = NULL;
     snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/KVM",
              cpu->cpu_index);
     qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,
                        cpu, QEMU_THREAD_JOINABLE);
-    while (!cpu->created) {
-        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
+    if(!kvm_enabled()) {
+        while (!cpu->created) {
+            qemu_cond_wait(&qemu_cpu_cond, cpu->mutex);
+        }
     }
 }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index d270c27..cebe73e 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1493,25 +1493,33 @@ static void pc_machine_initfn(Object *obj)
                              pc_machine_set_nvdimm, &error_abort);
 }
 
+static void do_cpu_apic_post_reset(void *arg)
+{
+    CPUState *cs = arg;
+    X86CPU *cpu = X86_CPU(cs);
+    /* Reset APIC after devices have been reset to cancel
+     * any changes that qemu_devices_reset() might have done.
+     */
+    if (cpu->apic_state) {
+        device_reset(cpu->apic_state);
+    }
+   if (boot_info.protected_mode && cpu_is_bsp(cpu)) {
+        reset_cpu(&cpu->env);
+    }
+}
+
+
 static void pc_machine_reset(void)
 {
     CPUState *cs;
-    X86CPU *cpu;
 
     qemu_devices_reset();
 
     CPU_FOREACH(cs) {
-        cpu = X86_CPU(cs);
-
-        /* Reset APIC after devices have been reset to cancel
-         * any changes that qemu_devices_reset() might have done.
-         */
-        if (cpu->apic_state) {
-            device_reset(cpu->apic_state);
-        }
-
-        if (boot_info.protected_mode && cpu_is_bsp(cpu)) {
-            reset_cpu(&cpu->env);
+        if(kvm_enabled()) {
+            async_run_on_cpu(cs, do_cpu_apic_post_reset, cs);
+        } else {
+            do_cpu_apic_post_reset(cs);
         }
     }
 
diff --git a/include/qom/cpu.h b/include/qom/cpu.h
index b7a10f7..859baa9 100644
--- a/include/qom/cpu.h
+++ b/include/qom/cpu.h
@@ -283,6 +283,7 @@ struct CPUState {
     uint32_t host_tid;
     bool running;
     struct QemuCond *halt_cond;
+    struct QemuMutex *mutex;
     bool thread_kicked;
     bool created;
     bool stop;
diff --git a/include/sysemu/cpus.h b/include/sysemu/cpus.h
index 3d1e5ba..57d3885 100644
--- a/include/sysemu/cpus.h
+++ b/include/sysemu/cpus.h
@@ -7,10 +7,14 @@ void qemu_init_cpu_loop(void);
 void resume_all_vcpus(void);
 void pause_all_vcpus(void);
 void cpu_stop_current(void);
+void wait_for_all_vcpus_init(void);
 
 void cpu_synchronize_all_states(void);
+void cpu_synchronize_all_states_async(void);
 void cpu_synchronize_all_post_reset(void);
+void cpu_synchronize_all_post_reset_async(void);
 void cpu_synchronize_all_post_init(void);
+void cpu_synchronize_all_post_init_async(void);
 
 void qtest_clock_warp(int64_t dest);
 
diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index 0e18f15..5fcc6cb 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -444,11 +444,20 @@ int kvm_physical_memory_addr_from_host(KVMState *s, void *ram_addr,
 #endif /* NEED_CPU_H */
 
 void kvm_cpu_synchronize_state(CPUState *cpu);
-void kvm_cpu_synchronize_post_reset(CPUState *cpu);
-void kvm_cpu_synchronize_post_init(CPUState *cpu);
+void kvm_cpu_synchronize_state_async(CPUState *cpu);
+void kvm_cpu_synchronize_post_reset(CPUState *cpu, bool async);
+void kvm_cpu_synchronize_post_init(CPUState *cpu, bool async);
+
 
 /* generic hooks - to be moved/refactored once there are more users */
 
+static inline void cpu_synchronize_state_async(CPUState *cpu)
+{
+    if (kvm_enabled()) {
+        kvm_cpu_synchronize_state_async(cpu);
+    }
+}
+
 static inline void cpu_synchronize_state(CPUState *cpu)
 {
     if (kvm_enabled()) {
@@ -456,17 +465,31 @@ static inline void cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+static inline void cpu_synchronize_post_reset_async(CPUState *cpu)
+{
+    if (kvm_enabled()) {
+        kvm_cpu_synchronize_post_reset(cpu, true);
+    }
+}
+
 static inline void cpu_synchronize_post_reset(CPUState *cpu)
 {
     if (kvm_enabled()) {
-        kvm_cpu_synchronize_post_reset(cpu);
+        kvm_cpu_synchronize_post_reset(cpu, false);
+    }
+}
+
+static inline void cpu_synchronize_post_init_async(CPUState *cpu)
+{
+    if (kvm_enabled()) {
+        kvm_cpu_synchronize_post_init(cpu, true);
     }
 }
 
 static inline void cpu_synchronize_post_init(CPUState *cpu)
 {
     if (kvm_enabled()) {
-        kvm_cpu_synchronize_post_init(cpu);
+        kvm_cpu_synchronize_post_init(cpu, false);
     }
 }
 
diff --git a/kvm-all.c b/kvm-all.c
index e7b66df..4b45574 100644
--- a/kvm-all.c
+++ b/kvm-all.c
@@ -1772,6 +1772,13 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+void kvm_cpu_synchronize_state_async(CPUState *cpu)
+{
+    if (!cpu->kvm_vcpu_dirty) {
+        async_run_on_cpu(cpu, do_kvm_cpu_synchronize_state, cpu);
+    }
+}
+
 static void do_kvm_cpu_synchronize_post_reset(void *arg)
 {
     CPUState *cpu = arg;
@@ -1780,9 +1787,13 @@ static void do_kvm_cpu_synchronize_post_reset(void *arg)
     cpu->kvm_vcpu_dirty = false;
 }
 
-void kvm_cpu_synchronize_post_reset(CPUState *cpu)
+void kvm_cpu_synchronize_post_reset(CPUState *cpu, bool async)
 {
-    run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, cpu);
+    if( async ) {
+        async_run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, cpu);
+    } else {
+        run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, cpu);
+    }
 }
 
 static void do_kvm_cpu_synchronize_post_init(void *arg)
@@ -1793,9 +1804,13 @@ static void do_kvm_cpu_synchronize_post_init(void *arg)
     cpu->kvm_vcpu_dirty = false;
 }
 
-void kvm_cpu_synchronize_post_init(CPUState *cpu)
+void kvm_cpu_synchronize_post_init(CPUState *cpu, bool async)
 {
-    run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, cpu);
+    if( async ) {
+        async_run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, cpu);
+    } else {
+        run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, cpu);
+    }
 }
 
 int kvm_cpu_exec(CPUState *cpu)
@@ -1810,7 +1825,7 @@ int kvm_cpu_exec(CPUState *cpu)
         return EXCP_HLT;
     }
 
-    qemu_mutex_unlock_iothread();
+    qemu_mutex_unlock(cpu->mutex);
 
     do {
         MemTxAttrs attrs;
@@ -1923,11 +1938,13 @@ int kvm_cpu_exec(CPUState *cpu)
         }
     } while (ret == 0);
 
-    qemu_mutex_lock_iothread();
+    qemu_mutex_lock(cpu->mutex);
 
     if (ret < 0) {
         cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);
+        qemu_mutex_lock_iothread();
         vm_stop(RUN_STATE_INTERNAL_ERROR);
+        qemu_mutex_unlock_iothread();
     }
 
     cpu->exit_request = 0;
diff --git a/target-i386/cpu.c b/target-i386/cpu.c
index d0b5b69..6ad0974 100644
--- a/target-i386/cpu.c
+++ b/target-i386/cpu.c
@@ -2872,6 +2872,18 @@ static void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
 }
 #endif
 
+static void do_cpu_apic_init(void *arg)
+{
+    Error *local_err = NULL;
+    DeviceState *dev =(DeviceState *)arg;
+    CPUState *cs = CPU(dev);
+    X86CPU *cpu = X86_CPU(dev);
+    X86CPUClass *xcc = X86_CPU_GET_CLASS(dev);
+    x86_cpu_apic_realize(cpu, &local_err);
+    cpu_reset(cs);
+    xcc->parent_realize(dev, &local_err);
+}
+
 
 #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
                            (env)->cpuid_vendor2 == CPUID_VENDOR_INTEL_2 && \
@@ -2883,7 +2895,6 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     X86CPU *cpu = X86_CPU(dev);
-    X86CPUClass *xcc = X86_CPU_GET_CLASS(dev);
     CPUX86State *env = &cpu->env;
     Error *local_err = NULL;
     static bool ht_warned;
@@ -2972,14 +2983,11 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
         ht_warned = true;
     }
 
-    x86_cpu_apic_realize(cpu, &local_err);
-    if (local_err != NULL) {
-        goto out;
+    if (kvm_enabled()) {
+        async_run_on_cpu(cs, do_cpu_apic_init, dev);
+    } else {
+        do_cpu_apic_init(dev);
     }
-    cpu_reset(cs);
-
-    xcc->parent_realize(dev, &local_err);
-
 out:
     if (local_err != NULL) {
         error_propagate(errp, local_err);
diff --git a/vl.c b/vl.c
index 5fd22cb..f85a967 100644
--- a/vl.c
+++ b/vl.c
@@ -753,6 +753,9 @@ void vm_start(void)
     if (runstate_is_running() && requested == RUN_STATE__MAX) {
         return;
     }
+    if (kvm_enabled()) {
+        wait_for_all_vcpus_init();
+    }
 
     /* Ensure that a STOP/RESUME pair of events is emitted if a
      * vmstop request was pending.  The BLOCK_IO_ERROR event, for
@@ -1745,7 +1748,7 @@ void qemu_system_reset(bool report)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
-    cpu_synchronize_all_states();
+    cpu_synchronize_all_states_async();
 
     if (mc && mc->reset) {
         mc->reset();
@@ -1755,7 +1758,7 @@ void qemu_system_reset(bool report)
     if (report) {
         qapi_event_send_reset(&error_abort);
     }
-    cpu_synchronize_all_post_reset();
+    cpu_synchronize_all_post_reset_async();
 }
 
 void qemu_system_guest_panicked(void)
@@ -4518,7 +4521,7 @@ int main(int argc, char **argv, char **envp)
 
     audio_init();
 
-    cpu_synchronize_all_post_init();
+    cpu_synchronize_all_post_init_async();
 
     numa_post_machine_init();
 

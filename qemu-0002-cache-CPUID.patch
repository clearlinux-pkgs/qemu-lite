commit ddb2a099d06cf0a9d28cde52553b06633fb6c23a
Author: Anthony Xu <anthony.xu@intel.com>
Date:   Wed Apr 6 11:13:07 2016 -0700

        There is thousands of system calls KVM_GET_SUPPORTED_CPUID during qemu boot,
        This patch caches cpuid info in qemu, reduces most of the system calls.
    
        Author: Chao Peng <chao.p.peng@linux.intel.com>
        Signed-off-by: Chao Peng <chao.p.peng@linux.intel.com>

diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index 0e18f15..d8d1320 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -523,4 +523,7 @@ int kvm_set_one_reg(CPUState *cs, uint64_t id, void *source);
  * Returns: 0 on success, or a negative errno on failure.
  */
 int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target);
+
+void kvm_arch_destroy(void);
+
 #endif
diff --git a/target-arm/kvm.c b/target-arm/kvm.c
index 3671032..c201732 100644
--- a/target-arm/kvm.c
+++ b/target-arm/kvm.c
@@ -180,6 +180,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 unsigned long kvm_arch_vcpu_id(CPUState *cpu)
 {
     return cpu->cpu_index;
diff --git a/target-i386/kvm.c b/target-i386/kvm.c
index 799fdfa..f0b17cc 100644
--- a/target-i386/kvm.c
+++ b/target-i386/kvm.c
@@ -103,6 +103,8 @@ static int has_xsave;
 static int has_xcrs;
 static int has_pit_state2;
 
+static struct kvm_cpuid2 *cpuid_cache;
+
 int kvm_has_pit_state2(void)
 {
     return has_pit_state2;
@@ -195,10 +197,15 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
-    int max = 1;
+    int max = 64;
+
+    if (cpuid_cache != NULL) {
+        return cpuid_cache;
+    }
     while ((cpuid = try_get_cpuid(s, max)) == NULL) {
         max *= 2;
     }
+    cpuid_cache = cpuid;
     return cpuid;
 }
 
@@ -316,8 +323,6 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
         ret |= cpuid_1_edx & CPUID_EXT2_AMD_ALIASES;
     }
 
-    g_free(cpuid);
-
     /* fallback for older kernels */
     if ((function == KVM_CPUID_FEATURES) && !found) {
         ret = get_para_features(s);
@@ -1161,6 +1166,13 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+    if (cpuid_cache != NULL) {
+        g_free(cpuid_cache);
+    }
+}
+
 static void set_v8086_seg(struct kvm_segment *lhs, const SegmentCache *rhs)
 {
     lhs->selector = rhs->selector;
diff --git a/target-mips/kvm.c b/target-mips/kvm.c
index 950bc05..8295bc3 100644
--- a/target-mips/kvm.c
+++ b/target-mips/kvm.c
@@ -56,6 +56,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     MIPSCPU *cpu = MIPS_CPU(cs);
diff --git a/target-ppc/kvm.c b/target-ppc/kvm.c
index c4c8146..01da4b0 100644
--- a/target-ppc/kvm.c
+++ b/target-ppc/kvm.c
@@ -129,6 +129,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 static int kvm_arch_sync_sregs(PowerPCCPU *cpu)
 {
     CPUPPCState *cenv = &cpu->env;
diff --git a/target-s390x/kvm.c b/target-s390x/kvm.c
index e1859ca..0f678f4 100644
--- a/target-s390x/kvm.c
+++ b/target-s390x/kvm.c
@@ -274,6 +274,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 unsigned long kvm_arch_vcpu_id(CPUState *cpu)
 {
     return cpu->cpu_index;
diff --git a/vl.c b/vl.c
index 3629336..199c3d4 100644
--- a/vl.c
+++ b/vl.c
@@ -544,6 +544,9 @@ const char *qemu_get_vm_name(void)
 
 static void res_free(void)
 {
+    if (kvm_enabled()) {
+        kvm_arch_destroy();
+    }
     g_free(boot_splash_filedata);
     boot_splash_filedata = NULL;
 }

commit f2e2ee5034a6560c6a0721c88a91de16264e127a
Author: Anthony Xu <anthony.xu@intel.com>
Date:   Wed Apr 6 12:22:49 2016 -0700

        build mptable in qemu, support SMP guest without BIOS
    
        Author: Chao Peng <chao.p.peng@linux.intel.com>
        Signed-off-by: Chao Peng <chao.p.peng@linux.intel.com>

diff --git a/hw/i386/Makefile.objs b/hw/i386/Makefile.objs
index b52d5b8..6de2b16 100644
--- a/hw/i386/Makefile.objs
+++ b/hw/i386/Makefile.objs
@@ -6,5 +6,5 @@ obj-y += intel_iommu.o
 obj-$(CONFIG_XEN) += ../xenpv/ xen/
 
 obj-y += kvmvapic.o
-obj-y += acpi-build.o
+obj-y += acpi-build.o mptable.o
 obj-y += pci-assign-load-rom.o
diff --git a/hw/i386/mptable.c b/hw/i386/mptable.c
new file mode 100644
index 0000000..6fc1aaa
--- /dev/null
+++ b/hw/i386/mptable.c
@@ -0,0 +1,289 @@
+#include "qemu/osdep.h"
+#include "mptable.h"
+#include "cpu.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/pci_bus.h"
+#include "hw/i386/ioapic.h"
+
+#define MPTABLE_SIG_FLOATING    "_MP_"
+#define MPTABLE_OEM             "QEMUCPU0"
+#define MPTABLE_PRODUCTID       "0.1         "
+#define MPTABLE_PCIBUSTYPE      "PCI   "
+#define MPTABLE_ISABUSTYPE      "ISA   "
+
+#define MPTABLE_STRNCPY(d, s)   memcpy(d, s, sizeof(d))
+
+#define MPTABLE_OFFSET              0x9FC00
+#define MPTABLE_MAX_SIZE            (32 << 15)
+
+struct mpf_intel {
+    char signature[4];              /* "_MP_"                       */
+    unsigned int physptr;           /* Configuration table address  */
+    unsigned char length;           /* Our length (paragraphs)      */
+    unsigned char specification;    /* Specification version        */
+    unsigned char checksum;         /* Checksum (makes sum 0)       */
+    unsigned char feature1;         /* Standard or configuration ?  */
+    unsigned char feature2;         /* Bit7 set for IMCR|PIC        */
+    unsigned char feature3;         /* Unused (0)                   */
+    unsigned char feature4;         /* Unused (0)                   */
+    unsigned char feature5;         /* Unused (0)                   */
+};
+
+#define MPC_SIGNATURE "PCMP"
+
+struct mpc_table {
+    char signature[4];
+    unsigned short length;          /* Size of table */
+    char spec;                      /* 0x01 */
+    char checksum;
+    char oem[8];
+    char productid[12];
+    unsigned int oemptr;            /* 0 if not present */
+    unsigned short oemsize;         /* 0 if not present */
+    unsigned short oemcount;
+    unsigned int lapic;             /* APIC address */
+    unsigned int reserved;
+};
+
+#define MP_PROCESSOR            0
+#define MP_BUS                  1
+#define MP_IOAPIC               2
+#define MP_INTSRC               3
+#define MP_LINTSRC              4
+
+struct mpc_cpu {
+    unsigned char type;
+    unsigned char apicid;           /* Local APIC number */
+    unsigned char apicver;          /* Its versions */
+    unsigned char cpuflag;
+    unsigned int cpufeature;
+    unsigned int featureflag;       /* CPUID feature value */
+    unsigned int reserved[2];
+};
+
+struct mpc_bus {
+    unsigned char type;
+    unsigned char busid;
+    unsigned char bustype[6];
+};
+
+#define MPC_APIC_USABLE         0x01
+
+struct mpc_ioapic {
+    unsigned char type;
+    unsigned char apicid;
+    unsigned char apicver;
+    unsigned char flags;
+    unsigned int apicaddr;
+};
+
+struct mpc_intsrc {
+    unsigned char type;
+    unsigned char irqtype;
+    unsigned short irqflag;
+    unsigned char srcbus;
+    unsigned char srcbusirq;
+    unsigned char dstapic;
+    unsigned char dstirq;
+};
+
+enum mp_irq_source_types {
+    mp_INT = 0,
+    mp_NMI = 1,
+    mp_SMI = 2,
+    mp_ExtINT = 3
+};
+
+#define MP_IRQDIR_DEFAULT       0
+#define MP_IRQDIR_HIGH          1
+#define MP_IRQDIR_LOW           3
+
+#define MP_APIC_ALL             0xFF
+
+#define CPU_ENABLED             1       /* Processor is available */
+#define CPU_BOOTPROCESSOR       2       /* Processor is the BP */
+#define KVM_APIC_VERSION        0x14    /* xAPIC */
+#define BUS_PCI_ID              0
+#define BUS_ISA_ID              1
+#define ISA_MASKOUT_IRQS        ((1<<2) |(1<<5) | (1<<9) | (1<<10) | (1<<11))
+
+static unsigned int mpf_checksum(unsigned char *mp, int len)
+{
+    unsigned int sum = 0;
+
+    while (len--)
+        sum += *mp++;
+
+    return sum & 0xFF;
+}
+
+static void* mpc_fill_cpu(struct mpc_cpu *mpc_cpu, unsigned int *entries)
+{
+    CPUState *cs;
+    X86CPU *cpu;
+
+    CPU_FOREACH(cs) {
+        cpu = X86_CPU(cs);
+        memset(mpc_cpu, 0, sizeof(*mpc_cpu));
+        mpc_cpu->type           = MP_PROCESSOR;
+        mpc_cpu->apicid         = cpu->apic_id;
+        mpc_cpu->apicver        = KVM_APIC_VERSION;
+        mpc_cpu->cpuflag        = CPU_ENABLED | (cpu->apic_id == 0 ?
+                                                 CPU_BOOTPROCESSOR : 0x00);
+        mpc_cpu->cpufeature     = 0x600;
+        mpc_cpu->featureflag    = 0x201;
+        mpc_cpu++;
+        (*entries)++;
+    }
+    return mpc_cpu;
+}
+
+static void* mpc_fill_bus(struct mpc_bus *mpc_bus, unsigned int *entries)
+{
+    mpc_bus->type   = MP_BUS;
+    mpc_bus->busid  = BUS_PCI_ID;
+    MPTABLE_STRNCPY(mpc_bus->bustype, MPTABLE_PCIBUSTYPE);
+    (*entries)++;
+
+    mpc_bus++;
+    mpc_bus->type   = MP_BUS;
+    mpc_bus->busid  = BUS_ISA_ID;
+    MPTABLE_STRNCPY(mpc_bus->bustype, MPTABLE_ISABUSTYPE);
+    (*entries)++;
+
+    return ++mpc_bus;
+}
+
+static void* mpc_fill_ioapic(struct mpc_ioapic *mpc_ioapic,
+                             unsigned int *entries)
+{
+    mpc_ioapic->type        = MP_IOAPIC;
+    mpc_ioapic->apicid      = 0;
+    mpc_ioapic->apicver     = KVM_APIC_VERSION;
+    mpc_ioapic->flags       = MPC_APIC_USABLE;
+    mpc_ioapic->apicaddr    = IO_APIC_DEFAULT_ADDRESS;
+    (*entries)++;
+
+    return ++mpc_ioapic;
+}
+
+static void* mpc_fill_io_intsrc(struct mpc_intsrc *mpc_intsrc,
+                                unsigned int *entries)
+{
+    int i, devfn;
+    PCIDevice *d;
+    PCIBus *bus = pci_find_primary_bus();
+
+    for (devfn = 0; devfn < ARRAY_SIZE(bus->devices); devfn++) {
+        d = bus->devices[devfn];
+        if (d) {
+            mpc_intsrc->type           = MP_INTSRC;
+            mpc_intsrc->irqtype        = mp_INT;
+            mpc_intsrc->irqflag        = MP_IRQDIR_HIGH;
+            mpc_intsrc->srcbus         = BUS_PCI_ID;
+            mpc_intsrc->srcbusirq      = PCI_SLOT(d->devfn) << 2 |
+                        (pci_get_byte(d->config + PCI_INTERRUPT_PIN) - 1);
+            mpc_intsrc->dstapic        = 0;
+            mpc_intsrc->dstirq         = pci_get_byte(d->config +
+                                                      PCI_INTERRUPT_LINE);
+            mpc_intsrc++;
+            (*entries)++;
+        }
+    }
+
+    for (i = 0; i < 16; i++) {
+        if (ISA_MASKOUT_IRQS & (1 << i)) {
+            continue;
+        }
+        mpc_intsrc->type           = MP_INTSRC;
+        mpc_intsrc->irqtype        = mp_INT;
+        mpc_intsrc->irqflag        = MP_IRQDIR_DEFAULT;
+        mpc_intsrc->srcbus         = BUS_ISA_ID;
+        mpc_intsrc->srcbusirq      = i;
+        mpc_intsrc->dstapic        = 0;
+        mpc_intsrc->dstirq         = i == 0 ? 2 : i;
+        mpc_intsrc++;
+        (*entries)++;
+    }
+
+    return mpc_intsrc;
+}
+
+static void* mpc_fill_local_intsrc(struct mpc_intsrc *mpc_intsrc,
+                                   unsigned int *entries)
+{
+    mpc_intsrc->type        = MP_LINTSRC;
+    mpc_intsrc->irqtype     = mp_ExtINT;
+    mpc_intsrc->irqflag     = MP_IRQDIR_DEFAULT;
+    mpc_intsrc->srcbus      = BUS_ISA_ID;
+    mpc_intsrc->srcbusirq   = 0;
+    mpc_intsrc->dstapic     = 0;
+    mpc_intsrc->dstirq      = 0;
+    (*entries)++;
+
+    mpc_intsrc++;
+    mpc_intsrc->type        = MP_LINTSRC;
+    mpc_intsrc->irqtype     = mp_NMI;
+    mpc_intsrc->irqflag     = MP_IRQDIR_DEFAULT;
+    mpc_intsrc->srcbus      = BUS_ISA_ID;
+    mpc_intsrc->srcbusirq   = 0;
+    mpc_intsrc->dstapic     = 0;
+    mpc_intsrc->dstirq      = 1;
+
+    (*entries)++;
+
+    return ++mpc_intsrc;
+}
+
+void mptable_build(void)
+{
+    struct mpf_intel *mpf_intel;
+    struct mpc_table *mpc_table;
+    void *p;
+    unsigned int entries = 0;
+    size_t size = MPTABLE_MAX_SIZE;
+
+    mpf_intel = cpu_physical_memory_map((hwaddr)MPTABLE_OFFSET, &size, 1);
+    if (!mpf_intel) {
+        fprintf(stderr,"unable to map mptable buffer: %s\n", strerror(errno));
+        exit(1);
+    }
+
+    memset(mpf_intel, 0, sizeof(*mpf_intel));
+    MPTABLE_STRNCPY(mpf_intel->signature, MPTABLE_SIG_FLOATING);
+    mpf_intel->length       = 1;
+    mpf_intel->specification= 4;
+    mpf_intel->physptr      = (unsigned int)MPTABLE_OFFSET + sizeof(*mpf_intel);
+    mpf_intel->checksum     = -mpf_checksum((unsigned char *)mpf_intel,
+                                            sizeof(*mpf_intel));
+
+    mpc_table = (void*)mpf_intel + sizeof(*mpf_intel);
+    memset(mpc_table, 0, sizeof(*mpc_table));
+
+    MPTABLE_STRNCPY(mpc_table->signature,   MPC_SIGNATURE);
+    MPTABLE_STRNCPY(mpc_table->oem,         MPTABLE_OEM);
+    MPTABLE_STRNCPY(mpc_table->productid,   MPTABLE_PRODUCTID);
+
+    mpc_table->spec         = 4;
+    mpc_table->lapic        = APIC_DEFAULT_ADDRESS;
+    p = mpc_table + 1;
+
+    p = mpc_fill_cpu(p, &entries);
+    p = mpc_fill_bus(p, &entries);
+    p = mpc_fill_ioapic(p, &entries);
+    p = mpc_fill_io_intsrc(p, &entries);
+    p = mpc_fill_local_intsrc(p, &entries);
+
+    mpc_table->oemcount     = entries;
+    mpc_table->length       = p - (void *)mpc_table;
+    mpc_table->checksum     = -mpf_checksum((unsigned char *)mpc_table,
+                                            mpc_table->length);
+
+    cpu_physical_memory_unmap(mpf_intel, MPTABLE_MAX_SIZE, 1, MPTABLE_MAX_SIZE);
+
+    size = (unsigned long)p - (unsigned long)mpf_intel;
+    if (size > MPTABLE_MAX_SIZE) {
+        fprintf(stderr,"mptable is too big\n");
+        exit(1);
+    }
+}
diff --git a/hw/i386/mptable.h b/hw/i386/mptable.h
new file mode 100644
index 0000000..7bf4d31
--- /dev/null
+++ b/hw/i386/mptable.h
@@ -0,0 +1,8 @@
+#ifndef HW_I386_MPTABLE_H
+#define HW_I386_MPTABLE_H
+
+#include "qemu/typedefs.h"
+
+void mptable_build(void);
+
+#endif
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index bcf3ac7..bdc7b93 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -39,6 +39,7 @@
 #include "elf.h"
 #include "asm/bootparam.h"
 #include "linux/const.h"
+#include "mptable.h"
 #include "multiboot.h"
 #include "hw/timer/mc146818rtc.h"
 #include "hw/timer/i8254.h"
@@ -2269,6 +2270,7 @@ static void pc_machine_reset(void)
         if (pcms->no_bios && cpu_is_bsp(cpu)) {
             set_cpu_regs(&cpu->env);
             set_zero_page(machine->kernel_cmdline);
+            mptable_build();
         }
     }
 }
